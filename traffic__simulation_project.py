# -*- coding: utf-8 -*-
"""Traffic _Simulation_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nE1ocasQVyZgNEjq8y4czhtAIxpmw93v
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import StandardScaler

# 1. مولد البيانات
class TrafficDataSimulator:
    def __init__(self, num_samples=1000):
        self.num_samples = num_samples

    def generate_data(self):
        # إنشاء بيانات عشوائية
        vehicle_count = np.random.randint(30, 200, size=self.num_samples)  # عدد المركبات
        speed = np.random.randint(30, 100, size=self.num_samples)  # سرعة المركبات
        # إضافة فترة الوقت (من 0 إلى 23 ساعة)
        time_of_day = np.random.randint(0, 24, size=self.num_samples)  # الوقت خلال اليوم
        congestion_level = self._generate_congestion_level(vehicle_count, speed, time_of_day)  # مستوى الازدحام
        return vehicle_count, speed, time_of_day, congestion_level

    def _generate_congestion_level(self, vehicle_count, speed, time_of_day):
        congestion_level = []
        for i in range(len(vehicle_count)):
            # التأثير الزمني:
            if 7 <= time_of_day[i] <= 9:  # فترة الذروة الصباحية (الساعة 7 - 9 صباحًا)
                if vehicle_count[i] > 100 and speed[i] < 50:
                    congestion_level.append(2)  # High
                elif vehicle_count[i] > 50 and speed[i] < 70:
                    congestion_level.append(1)  # Medium
                else:
                    congestion_level.append(0)  # Low
            elif 17 <= time_of_day[i] <= 19:  # فترة الذروة المسائية (الساعة 5 - 7 مساءً)
                if vehicle_count[i] > 80 and speed[i] < 60:
                    congestion_level.append(2)  # High
                elif vehicle_count[i] > 40 and speed[i] < 80:
                    congestion_level.append(1)  # Medium
                else:
                    congestion_level.append(0)  # Low
            else:  # باقي الأوقات
                if vehicle_count[i] > 100 and speed[i] < 50:
                    congestion_level.append(2)  # High
                elif vehicle_count[i] > 50 and speed[i] < 70:
                    congestion_level.append(1)  # Medium
                else:
                    congestion_level.append(0)  # Low
        return np.array(congestion_level)

# 2. التصور
class TrafficDataVisualizer:
    def __init__(self, vehicle_count, speed, congestion_level):
        self.vehicle_count = vehicle_count
        self.speed = speed
        self.congestion_level = congestion_level

    def plot_data(self):
        plt.figure(figsize=(10, 6))

        # تجميع البيانات حسب مستوى الازدحام (Low, Medium, High)
        congestion_counts = [np.sum(self.congestion_level == level) for level in np.unique(self.congestion_level)]

        # رسم بياني شريطي لتوزيع مستويات الازدحام
        plt.bar(np.unique(self.congestion_level), congestion_counts, color=['green', 'orange', 'red'])

        plt.title("Traffic Congestion Level Distribution")
        plt.xlabel("Congestion Level")
        plt.ylabel("Frequency")
        plt.xticks([0, 1, 2], ["Low", "Medium", "High"])  # تحويل الفئات إلى أسماء
        plt.show()

# 3. النموذج (التعلم الآلي)
class TrafficCongestionPredictor:
    def __init__(self):
        self.model = LogisticRegression(max_iter=1000)  # نموذج الانحدار اللوجستي

    def train_model(self, vehicle_count, speed, time_of_day, congestion_level):
        # دمج البيانات: عدد المركبات، السرعة، وفترة الوقت
        X = np.column_stack((vehicle_count, speed, time_of_day))  # المميزات: عدد المركبات، السرعة، وقت اليوم
        y = congestion_level  # الهدف: مستوى الازدحام

        # استخدام StandardScaler لتحجيم البيانات
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)  # تحجيم البيانات

        # تقسيم البيانات إلى تدريب واختبار
        X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

        # تدريب النموذج
        self.model.fit(X_train, y_train)

        # التنبؤ بالنتائج
        y_pred = self.model.predict(X_test)

        # حساب الدقة
        accuracy = accuracy_score(y_test, y_pred)
        print(f"Model Accuracy: {accuracy * 100:.2f}%")

    def predict_congestion(self, vehicle_count, speed, time_of_day):
        # التنبؤ بالازدحام باستخدام البيانات المدخلة
        return self.model.predict(np.array([[vehicle_count, speed, time_of_day]]))[0]

# 4. دمج الكود معا
def main():
    # توليد البيانات
    simulator = TrafficDataSimulator(num_samples=1000)
    vehicle_count, speed, time_of_day, congestion_level = simulator.generate_data()

    # التصور
    visualizer = TrafficDataVisualizer(vehicle_count, speed, congestion_level)
    visualizer.plot_data()  # عرض الرسم البياني الشريطي لتوزيع مستويات الازدحام

    # تدريب النموذج
    predictor = TrafficCongestionPredictor()
    predictor.train_model(vehicle_count, speed, time_of_day, congestion_level)

    # اختبار النموذج
    test_vehicle_count = 100
    test_speed = 60
    test_time_of_day =  8
    predicted_congestion = predictor.predict_congestion(test_vehicle_count, test_speed, test_time_of_day)
    print(f"Predicted Congestion for {test_vehicle_count} vehicles, {test_speed} km/h speed, and {test_time_of_day} hour: {predicted_congestion}")

if __name__ == "__main__":
    main()